
/////////controller///////

//funcao para solicitar o token
const solicitarToken = async function(email, contentType){
    try {
        if(contentType == 'application/json'){
           return message.ERROR_CONTENT_TYPE 
        }
        
        if(!usuario.email || usuario.email === ''){
            return message.ERROR_REQUIRED_FIELDS
        }

        let resultUsuario = await usuariosDAO.selectByEmailUsuario(email)
        if(!resultUsuario){
            return message.ERROR_NOT_FOUND
        }
        
        //math.random() serve para deixar o tokn em ordem aleatoria
        //math.flor() impede que o token receba qualquer coisa que nao seja numero (-, ;, )
        let token = Math.floor(100000 + Math.random() * 90000).toString();
        let expiracao = new Date(Date.now() + 15 * 60 * 1000) // validade 15 minutos
        
        let resultToken = await usuariosDAO.InsertSenha(id, token, expiracao)

        if(resultToken){
            await  enviarEmail(resultUsuario.email, 'Redefinição de senha', `Seu token para redefinição de senha é: ${token}. Ele é válido por 15 minutos.`)
            return message.SUCESS_CREATED_ITEM
        }else {
            return message.ERROR_INTERNAL_SERVER_MODEL//415
        }

    } catch (error) {
        return message.ERROR_INTERNAL_SERVER_CONTROLLER
    }
}

//função valida o token
const validarToken = async function(token, contentType){
    try {
        if(contentType == 'application/json'){
            return message.ERROR_CONTENT_TYPE
        }

        if(!token || token === ''){
            return message.ERROR_REQUIRED_FIELDS
        }

        let resultToken = await usuariosDAO.updateStatusExpirado(token)
        if(!resultToken){
            return message.ERROR_INVALID_CODE
        }

        if(new Date(resultToken.expiracao) < new Date()){
            return message.ERROR_CODE_EXPIRED
        }

        return{ status: true, status_code: 200, message: 'Token validado com sucesso!' }
    
    } catch (error) {
        console.log("ERRO AO VALIDAR O CODIGO", error)
        return message.ERROR_INTERNAL_SERVER_CONTROLLER
    }
}

const redefinirSenha = async function(dados,  contentType){
    try {
        if(contentType == 'application/json'){
            return message.ERROR_CONTENT_TYPE
        }

        if(!dados.email || dados.email === ''){
            return message.ERROR_REQUIRED_FIELDS
        }

        let resultUsuario = await usuariosDAO.selectByToken(dados.token)
        if(!resultUsuario){
            return message.ERROR_CODE_EXPIRED
        }
   
        let senhaHash = await bcrypt.hash(dados.senha, 10)
        let resultUpdateSenha = await usuariosDAO.updateUsuario({
            id: resultUsuario.id,
            senha: senhaHash
        })

        if(resultUpdateSenha){
            await  usuariosDAO.updateStatusExpirado(resultUsuario.id)
            return message.SUCCESS_PASSWORD_RESET
        }else {
            return message.ERROR_INTERNAL_SERVER_MODEL
        }

    } catch (error) {
        console.log("ERRO NO REDEFINIR SENHA --> ", error )
        return message.ERROR_INTERNAL_SERVER_CONTROLLER
    }
}

////////////////model///////////

//função para busca pelo ID 
const selectByIdUsuario = async function (id){
    try {

        let result = await prisma.$queryRaw`CALL search_usuario_id(${id});`

        if(result)
            return result
        else 
          return false

    } catch (error) {
        return false 
    }
    }

const selectByEmailUsuario = async function (email) {
    try {
        let sql = `SELECT * FROM tbl_usuario WHERE email = '${email}'`;
        let result = await prisma.$queryRawUnsafe(sql);
        return result && result.length > 0 ? result[0] : false;
    } catch (error) {
        console.log("ERRO AO BUSCAR USUARIO POR EMAIL:", error);
        return false;
    }
}

//Função para inserir um novo registro de redefinição de senha
const InsertSenha = async function (id, token, data_expiracao){
    try {
        let sql = `
        insert into tbl_redefinirsenha (id, token, data_expiracao)
        values (
            ${id}, 
            '${token}', 
            '${data_expiracao.toISOString().slice(0, 19).replace('T', ' ')}'
         );
        `

        let result = await prisma.$executeRawUnsafe(sql)

        if(result){
            let sql = `
             select * from tbl_redefinirsenha where id = ${id} order by criacao desc limit 1;
            `

            let criacaoRegistro = await prisma.$queryRawUnsafe(sql)
            return criacaoRegistro[0]
        }else{
            return false
        }
    } catch (error) {
        return false
    }
}

//Função para selecioar por token
const selectByToken = async function(token){
    try {
        let sql = `
        select * from tbl_redefinirSenha where token = '${token}' and expirado = false order by criacao desc limit 1;
        `

        let result = await prisma.$queryRawUnsafe(sql)
        return result && result.length > 0 ? result[0] : false
    } catch (error) {
        console.error("error ao selecionar por token ", error)
        return false
    }
}

//Função para atualizar o status de expirado
const updateStatusExpirado = async function(id){

    try {
        let sql = `
        update tbl_redefinirSenha set expirado = true where id = ${id};
        `

        let result = await prisma.$executeRawUnsafe(sql)

       if (result) {
        return true
        
       } else {
         return false
       }
    } catch (error) {
        return false
    }
}
